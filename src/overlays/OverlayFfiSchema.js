// Generates a Rust FFI-safe struct definition for EdgeZoneCognitiveOverlayDescriptor.
// Keeps Rust edge runtimes schema-locked to the JS overlay descriptor.

import EdgeZoneCognitiveOverlay from "./EdgeZoneCognitiveOverlay.js";

/**
 * Canonical field ordering shared between JS descriptor and Rust struct.
 * This must stay in sync with EdgeZoneCognitiveOverlay.toFfiDescriptor().
 */
const OVERLAY_FFI_FIELDS = [
  // Primary keys / ids
  { name: "run_id",                       rustType: "String" },
  { name: "motif_id",                     rustType: "String" },
  { name: "node_id",                      rustType: "String" },
  { name: "overlay_id",                   rustType: "String" },

  // Identity / anchors
  { name: "did",                          rustType: "Option<String>" },
  { name: "content_hash",                 rustType: "String" },
  { name: "transparency_run_id",          rustType: "String" },
  { name: "transparency_anchor_ref",      rustType: "String" },
  { name: "transparency_ledger",          rustType: "String" },

  // XR spatial anchoring
  { name: "spatial_anchor_id",            rustType: "String" },
  { name: "space_id",                     rustType: "String" },
  { name: "reference_frame",              rustType: "String" },
  { name: "dom_stability_signature",      rustType: "String" },

  // Neuromorphic activation
  { name: "motif_type",                   rustType: "String" },
  { name: "motif_signature",              rustType: "String" },
  { name: "activation_threshold",         rustType: "f32" },
  { name: "deactivation_threshold",       rustType: "f32" },
  { name: "decay_ms",                     rustType: "u32" },

  // Scheduling budgets
  { name: "cpu_budget_ms",                rustType: "u32" },
  { name: "gpu_budget_ms",                rustType: "u32" },
  { name: "sensor_access_window_ms",      rustType: "u32" },
  { name: "mesh_persistence_ms",          rustType: "u32" },
  { name: "max_concurrent_instances",     rustType: "u32" },

  // Overlay payload hints
  { name: "overlay_kind",                 rustType: "String" },
  { name: "overlay_priority",             rustType: "f32" },
  { name: "payload_uri",                  rustType: "String" },
  { name: "payload_content_type",         rustType: "String" },

  // Tags / flags
  { name: "tags",                         rustType: "Vec<String>" },
  { name: "audit_flags",                  rustType: "Vec<String>" },
  { name: "created_at",                   rustType: "String" }
];

/**
 * Generate the Rust struct code as a string.
 * Options:
 *  - derive: array of Rust derives, e.g. ["Debug", "Clone", "serde::Serialize", "serde::Deserialize"]
 *  - structName: override struct name (default "EdgeZoneCognitiveOverlayDescriptor")
 */
export function generateRustOverlayStruct(options = {}) {
  const structName = options.structName || "EdgeZoneCognitiveOverlayDescriptor";
  const derives = Array.isArray(options.derive) && options.derive.length
    ? options.derive
    : ["Debug", "Clone", "serde::Serialize", "serde::Deserialize"];

  const deriveLine = `#[derive(${derives.join(", ")})]`;
  const attrsLine = '#[repr(C)]';

  const fields = OVERLAY_FFI_FIELDS.map(f => `    pub ${f.name}: ${f.rustType},`).join("\n");

  const code = [
    "// Auto-generated by OverlayFfiSchema.js",
    "// Keep in sync with EdgeZoneCognitiveOverlay.toFfiDescriptor() in JS.",
    "",
    "use serde::{Serialize, Deserialize};",
    "",
    deriveLine,
    attrsLine,
    `pub struct ${structName} {`,
    fields,
    "}",
    ""
  ].join("\n");

  return code;
}

/**
 * Emit a complete Rust module string, including a constructor helper that
 * can be filled from a JS-sourced JSON descriptor on the Rust side.
 */
export function generateRustOverlayModule(options = {}) {
  const structName = options.structName || "EdgeZoneCognitiveOverlayDescriptor";
  const structCode = generateRustOverlayStruct({ ...options, structName });

  const implLines = [
    `impl ${structName} {`,
    "    /// Build from a JSON descriptor represented as serde_json::Value.",
    "    /// Expects the same keys as produced by EdgeZoneCognitiveOverlay.toFfiDescriptor().",
    "    pub fn from_json(value: &serde_json::Value) -> serde_json::Result<Self> {",
    "        serde_json::from_value(value.clone())",
    "    }",
    "",
    "    /// Primary composite key (run_id, motif_id) for SQLite lookups.",
    "    pub fn composite_key(&self) -> (String, String) {",
    "        (self.run_id.clone(), self.motif_id.clone())",
    "    }",
    "}",
    ""
  ].join("\n");

  return [structCode, implLines].join("\n");
}

/**
 * Simple runtime check to ensure JS descriptor fields match OVERLAY_FFI_FIELDS.
 * This can be called in tests to guard against drift.
 */
export function validateOverlayDescriptorShape(sampleConfig) {
  const overlay = new EdgeZoneCognitiveOverlay(sampleConfig);
  const descriptor = overlay.toFfiDescriptor();
  const missing = [];
  const extra = [];

  for (const field of OVERLAY_FFI_FIELDS) {
    if (!(field.name in descriptor)) {
      missing.push(field.name);
    }
  }
  for (const key of Object.keys(descriptor)) {
    if (!OVERLAY_FFI_FIELDS.find(f => f.name === key)) {
      extra.push(key);
    }
  }

  return { ok: missing.length === 0 && extra.length === 0, missing, extra };
}

export default {
  OVERLAY_FFI_FIELDS,
  generateRustOverlayStruct,
  generateRustOverlayModule,
  validateOverlayDescriptorShape
};
